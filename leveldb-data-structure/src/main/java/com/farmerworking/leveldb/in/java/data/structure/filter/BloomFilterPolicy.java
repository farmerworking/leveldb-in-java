package com.farmerworking.leveldb.in.java.data.structure.filter;

import com.farmerworking.leveldb.in.java.api.FilterPolicy;
import com.farmerworking.leveldb.in.java.common.IHash;

import java.util.List;

public class BloomFilterPolicy implements FilterPolicy {
    private int k;
    private int bitsPerKey;
    private IHash hash;

    public BloomFilterPolicy(int bitsPerKey) {
        this.hash = IHash.getInstance();
        this.bitsPerKey = bitsPerKey;

        // We intentionally round down to reduce probing cost a little bit
        k = (int)(bitsPerKey * 0.69);  // 0.69 =~ ln(2)
        if (k < 1) k = 1;
        if (k > 30) k = 30;
    }

    @Override
    public String name() {
        return "leveldb.BuiltinBloomFilter2";
    }

    @Override
    public String createFilter(List<String> keys) {
        // Compute bloom filter size (in both bits and bytes)
        int bits = keys.size() * bitsPerKey;

        // For small n, we can see a very high false positive rate.  Fix it
        // by enforcing a minimum bloom filter length.
        if (bits < 64) bits = 64;

        int bytes = (bits + 7) / 8;
        bits = bytes * 8;

        char[] array = new char[bytes + 1];
        for (int i = 0; i < keys.size(); i++) {
            // Use double-hashing to generate a sequence of hash values.
            // See analysis in [Kirsch,Mitzenmacher 2006].
            int h = bloomHash(keys.get(i).toCharArray());
            int delta = (h >>> 17) | (h << 15);  // Rotate right 17 bits
            for (int j = 0; j < k; j++) {
                int bitpos = Integer.remainderUnsigned(h, bits);
                array[bitpos/8] |= (1 << (bitpos % 8));
                h += delta;
            }
        }

        array[array.length - 1] = (char) k;// Remember # of probes in filter
        return new String(array);
    }

    @Override
    public boolean keyMayMatch(String key, String filter) {
        if (filter == null) return false;

        int len = filter.length();
        if (len < 2) return false;

        char[] array = filter.toCharArray();
        int bits = (len - 1) * 8;

        // Use the encoded k so that we can read filters generated by
        // bloom filters created using different parameters.
        int k = array[len-1];
        if (k > 30) {
            // Reserved for potentially new encodings for short bloom filters.
            // Consider it a match.
            return true;
        }

        int h = bloomHash(key.toCharArray());
        int delta = (h >>> 17) | (h << 15);  // Rotate right 17 bits
        for (int i = 0; i < k; i++) {
            int bitpos = Integer.remainderUnsigned(h, bits);
            if ((array[bitpos/8] & (1 << (bitpos % 8))) == 0) return false;
            h += delta;
        }
        return true;
    }

    private int bloomHash(char[] chars) {
        return hash.hash(chars, 0xbc9f1d34);
    }
}
